<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
 <title>mod_qos - Denial of Service Defense</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />
<meta name="author" content="Pascal Buchbinder" />
<meta name="KeyWords" content="Quality of Service, Apache Web Server, Web application security, WAF, Open Source Software, AdNovum Informatik, Secure Reverse Proxy, Denial of Service (DoS) Prevention" />
<link rel="shortcut icon" href="favicon.ico" />
<style TYPE="text/css">
<!--  
  body {
	background-color: white;
	color: black;
	font-family: sans-serif, arial, verdana;
	font-weight: normal;
	text-align: left;
  }
  a:link    { color:#00673F; text-decoration:none; }
  a:visited { color:#00673F; text-decoration:none; }
  a:focus   { color:black; text-decoration:underline; }
  a:hover   { color:black; text-decoration:underline; }
  a:active  { color:black; text-decoration:underline; }
  .btable   { font-size:0.75em; }
-->
</style>
</head>
<body>
<!--

 Quality of service module for Apache Web Server.

 See http://opensource.adnovum.ch/mod_qos/ for further details.

 Copyright (C) 2016 Pascal Buchbinder

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 MA 02110-1301, USA.

-->
<table>
<tbody>
<tr><td><img src="images/mod_qos_s.gif" alt="mod_qos" /></td>
    <td style="vertical-align: bottom;"><h1>Denial of Service Defense</h1></td></tr>
<tr><td>&nbsp;</td>
    <td>


<p>
mod_qos cannot only be used to implement QoS by controlling your Apache 
web server's traffic but may also help you to protect 
your web site against denial of service (DoS) attacks. The two features 
of mod_qos helping you in doing this, are the possibility to measure the 
bandwidth used for a TCP connection (and the possibility to enforce that 
the requirements concerning the minimum bandwidth is fulfilled) and the
existence of event counters per client's IP addresses (allowing you 
to limit the number of events a client is allowed cause on your web site).
</p>
<p>
<i>
Note: Multiple users may share an IP addresses (IP address is not 
unique per user) when using an intermediate proxy server. This is 
especially true for B2B applications.
</i>
</p>
<p>
This documentation shall give you an idea on how you could use mod_qos 
within your Apache web server to defense against the following DoS attacks:
<ul>
<li><i>Low-bandwidth DoS attacks</i><br>
The attacker tries to keep many TCP connections to your web server open, 
only sending partiality request data periodically (just enough not triggering 
any inactivity timeouts). The target is to occupy all available connections 
(running threads of your Apache server) so that nobody else can connect.
</li>
<li><i>HTTP GET/POST flood DoS attacks</i><br>
The attacker sends a huge amount of HTTP requests to your web server without 
awaiting the server's response. This requires only little traffic for the 
attacker but may occupy your server's threads and consumes computing resources 
(CPU, memory). Some attackers scan your web site prior an attack measuring 
the duration it takes to answer the request in order to find out which one are 
the "most expensive" HTTP requests (consuming most time while being processed by 
your web server).
</li>
</ul>
</p>
<p>
The following is a step-by-step checklist about potential configuration 
options you want to apply to improve your Apache server's DoS resistance. 
It shall give you an idea about which parameter you might want to set.
</p>

<a name="basic"></a>
<h3>Basic Settings</h3>
<p>
Hardware is inexpensive. Today's CPUs offers many cores allowing the processing 
of many threads in parallel and prices for memory are as low as never before. So allow 
your Apache server to serve many requests / TCP connections in parallel by setting 
a "high" value for its <a href="http://httpd.apache.org/docs/2.2/mod/mpm_common.html#maxclients"><code>MaxClients</code> <img src="images/link.png"/></a> 
parameter (and the corresponding <code>ServerLimit</code>/<code>ThreadsPerChild</code>  
values). I'm going to use <i>896</i> in the following examples. This is not an absolute 
value. Its probably not even a particular "high" value if you are fighting against a 
<i>low-bandwidth DoS attack</i>. Maybe it is fine for a quad-core Intel CPU serving 
several thousand concurrent users (assuming you are running the Apache server as your 
web tier only and not using more than half of the possible connections in the normal case)
but you might choose a different value suitable for your environment (note that 
each tread requires about 1 to 2 MB of memory). Just adapt all other values accordingly.
</p>
<p>
Other important Apache base settings concern timeouts. 
One is the <a href="http://httpd.apache.org/docs/2.2/mod/core.html#timeout"><code>TimeOut</code> <img src="images/link.png"/></a>  
directive defining the idle timeout while waiting for data on the network socket, 
the other directive is 
<a href="http://httpd.apache.org/docs/2.2/mod/core.html#keepalivetimeout"><code>KeepAliveTimeout</code> <img src="images/link.png"/></a>, telling the Apache server for how long to 
wait for a subsequent request before closing an idle connection. Keep-Alive is an
important feature to accelerate your web server but you should disable it if the 
server runs out of free connections. Disabling Keep-Alive will give more users a 
chance to connect to your server and send a HTTP request if your server becomes too busy and don't 
has any free slots anymore. mod_qos's <a href="index.html#QS_SrvMaxConnClose"><code>QS_SrvMaxConnClose</code></a> directive allows you to disable Keep-Alive in such a situation automatically.
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# maximum number of active TCP connections is limited to 896 (limited
# by the available memory, adjust the settings according to the used
# hardware):
MaxClients                          896

# idle timeout (while the server is waiting for TCP packets):
TimeOut                              10

# keep alive (enabled, but only until 85% of all connections are busy):
KeepAlive                            on
KeepAliveTimeout                      5
MaxKeepAliveRequests                 30
<a href="index.html#QS_SrvMaxConnClose">QS_SrvMaxConnClose</a>                   85%
</pre></td></tr></table>

<a name="connections"></a>
<h3>Connections per IP</h3>
<p>
There is no reason to allow a single IP address to open an unlimited number of 
TCP connections. The <a href="index.html#QS_SrvMaxConnPerIP"><code>QS_SrvMaxConnPerIP</code></a> 
directive can be used to limit the connections a single IP is allowed to open.
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# don't allow more than 30 TCP connections per client source address
# if the server has 500 or more open connections:
<a href="index.html#QS_SrvMaxConnPerIP">QS_SrvMaxConnPerIP</a>               30 500
</pre></td></tr></table>

<a name="datarate"></a>
<h3>Minimum Data Rate</h3>
<p>
The definition of a minimum upload/download throughput a client must generate 
(the bytes sent/received by the client per seconds) is a very important protection 
mechanism against <i>low-bandwidth DoS attacks</i>. 
The <a href="index.html#QS_SrvMinDataRate"><code>QS_SrvMinDataRate</code></a> directive 
can be used to implement this rule.
</p>
Syntax: <code><a href="index.html#QS_SrvMinDataRate">QS_SrvMinDataRate</a> &lt;bytes per second&gt; &lt;max bytes per second&gt; &lt;connections&gt;</code><br>

<p>It offers three parameters. The first defines the 
minimum data rate a client must achieve when this limitation becomes active and the 
second parameter defines the throughput a client must achive when the server reaches 
its <code>MaxClients</code> setting. The third parameter defines the number of busy 
connections to enable this restriction.
</p>
<img src="images/SrvMinDataRate.png"/>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# minimum request/response data reate if the server has 500 or more
# open connections:
<a href="index.html#QS_SrvMinDataRate">QS_SrvMinDataRate</a>          120 1500 500
</pre></td></tr></table>
<p>
You might also want to have a look at the Apache module 
<a href="http://httpd.apache.org/docs/2.2/mod/mod_reqtimeout.html">mod_reqtimeout <img src="images/link.png"/></a> 
(available since Apache 2.2.15) which may be used to set various timeouts for 
receiving the request headers and the request body from the client.
</p>

<a name="block"></a>
<h3>Repeat Offender</h3>
<p>
A very effective means of protection is the possibility to block client 
IP addresses automatically for a certain period if they violate a rule 
multiple times respectively if they cause errors many times. 
The <a href="index.html#QS_ClientEventBlockCount"><code>QS_ClientEventBlockCount</code></a> 
directive can be used to do this. It defines how often a "block event" (the Apache 
process environment variable <a href="index.html#QS_Block"><code>QS_Block</code></a>) 
may occur during a defined period of time. This enhances the effect of the above limitations. 
Incoming TCP connections are rejected if a client IP address reaches this threshold until 
the limitation expires.
</p>
<p>
The <a href="index.html#QS_SetEnvIfStatus"><code>QS_SetEnvIfStatus</code></a> is one of mod_qos's 
directive which may be used to define an event which must not occur too frequently.
</p>
<p>
The following example blocks clients if they cause more than 20 errors within 5 minutes.
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# block clients violating some basic rules frequently (don't allows more than 20
# violations within 5 minutes):
<a href="index.html#QS_ClientEventBlockCount">QS_ClientEventBlockCount</a> 20 300
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        400                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        405                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        406                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        408                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        413                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        414                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        500                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        <a href="index.html#QS_SrvMinDataRate">QS_SrvMinDataRate</a>  <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        <a href="index.html#QS_SrvMaxConnPerIP">QS_SrvMaxConnPerIP</a> <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        <a href="index.html#BrokenConnection">BrokenConnection</a>   <a href="index.html#QS_Block">QS_Block</a>
</pre></td></tr></table>
<p>
This is just an example of events you might want to limit.<br>
If you want to prevent from SSL DoS attacks as well, you might also want to block 
clients opening TCP connections not sending any HTTP data.
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        <a href="index.html#NullConnection">NullConnection</a>     <a href="index.html#QS_Block">QS_Block</a>
</pre></td></tr></table>

<a name="clients"></a>
<h3>Requests per IP</h3>
<p>
Rules, limiting a clients number of requests to a resource, may be configured using the 
<a href="index.html#QS_ClientEventLimitCount"><code>QS_ClientEventLimitCount</code></a> 
directive. This provides an event counter per IP address and you may specify how 
ofen a client is allowed to trigger this event within a defined period of time. Such a limitation 
might defense <i>HTTP GET/POST flood DoS attacks</i>, especially if you know which 
requests are the most expensive ones / which URLs provide the greatest risk of being attacked.
</p>
<p>You may use any request attributes to distinguish between "expensive" (resources 
your server takes long to process) and "inexpensive" (like static resource files which 
can be send to the client immediately). You can also define different attribues and 
configure more than one counter per IP (each counter is idenitfied by the specified name).
One attribute could be the request's URL and you may use the 
<a href="http://opensource.adnovum.ch/mod_setenvifplus/#SetEnvIfPlus"><code>SetEnvIfPlus</code></a> 
directive to detect them and to increment the counter.<br>
You can use the <code><a href="qslog.1.html">qslog</a></code> tool 
(option <code>-pu</code>) to analyze log data (or just use any other log data management 
tool). You should not only search your Apache server's log about "slow requests" but also 
check how many requests are issued by a single IP address to decide what limitations 
you want to configure (which URLs and how often).
</p>
<p>
For the following example, lets assume that requests to static resources (jpg,gif,css,...) 
are cheap (quickly processed by your server) and other requests expensive (takes long to be 
processed) while the most expensive URL path is <code>/generateReport.php</code>. 
Therefore, you won't need to set any penalty when accessing a static resource. 
Other resources are marked by "1" (allowing a client to access them 20 times per minute) 
while requests to the "most expensive" resource <code>/generateReport.php</code> are burden by a 
penalty of "2" (may be accessed only 10 times per minute).<br>
It is also possible that you enable this limitation only if the server 
reaches a predefined number of busy connections (no limitation if it is not necessary). 
You can achieve this by deleting the event variable (<code>SlowRequest</code> 
in this example) if the server has less connections. 
The <a href="index.html#QS_AllConn"><code>QS_AllConn</code></a> 
variable tells you the number of busy TCP connections and the 
<a href="index.html#QS_SetEnvIf"><code>QS_SetEnvIf</code></a> directive 
allows you to set or unset variables. The following example unset the
<code>SlowRequest</code> variable as long as the server has less than 499 connections.<br>
Clients which violates this request violation may be blocked for an even 
longer period of time. This is implemented by a second counter <code>SlowRepeatedlySlow</code>.
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# don't allow a client IP to access a "handler" (not a static resource like
# a jpg, gif, ..) more than 20 times per minute:
<a href="index.html#QS_ClientEventLimitCount">QS_ClientEventLimitCount</a>          20 60 <a href="index.html#QS_Limit">SlowRequest</a>
<a href="http://opensource.adnovum.ch/mod_setenvifplus/#SetEnvIfPlus">SetEnvIfPlus</a>              Request_URI / SlowRequest=1
<a href="http://opensource.adnovum.ch/mod_setenvifplus/#SetEnvIfPlus">SetEnvIfPlus</a>              Request_URI /generateReport.php SlowRequest=2
<a href="http://opensource.adnovum.ch/mod_setenvifplus/#SetEnvIfPlus">SetEnvIfPlus</a>              Request_URI .*\.(jpg)|(jpeg)|(gif)|(png)|(js)|(css)$ !SlowRequest

# disable any event counting if the server has less than 499 connections:
<a href="index.html#QS_SetEnvIf">QS_SetEnvIf</a>               <a href="index.html#QS_AllConn">QS_AllConn</a>=^[1234]?[0-9]{1,2}$ !SlowRequest

# deny a client IP for 10 minutes if he violates the rule above 3 times:
<a href="index.html#QS_ClientEventLimitCount">QS_ClientEventLimitCount</a>          3 600 <a href="index.html#QS_Limit">SlowRepeatedlySlow</a>
<a href="index.html#QS_SetEnvIf">QS_SetEnvIf</a>      <a href="index.html#_Counter">SlowRequest_Counter</a>=20 SlowRepeatedlySlow=1
</pre></td></tr></table> 

<a name="country"></a>
<h3>Country Specific Rules</h3>
<p>
Some web sites may have content that is only of regional interest, e.g., a site whose 
content is written in German has probably most visitors from countries where German is 
an officially spoken language. This allows you to prefer clients connecting from one 
of those country only in the case your server runs out of free TCP connections.
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# loads the GEO IP database and allows only client connections from
# Germany, Austria or Switzerland if the number of busy connections
# server reaches 700:
<a href="index.html#QS_ClientGeoCountryDB">QS_ClientGeoCountryDB</a>          conf/GeoIPCountryWhois.csv
<a href="index.html#QS_ClientGeoCountryPriv">QS_ClientGeoCountryPriv</a>        DE,AT,CH 700
</pre></td></tr></table> 
<p>
Geolocation databases that work with mod_qos are available from MaxMind or IP2Location.
</p>

<a name="prefer"></a>
<h3>Prefer Known Clients</h3>
<p>
mod_qos may prefer "known" client IP addresses in the case that too 
many clients access the server. "Known" clients are those 
which have once been identified by the application by setting 
the corresponding HTTP response header. Such identification 
may happen at successful user login. Connections from clients 
which are not known to mod_qos (never marked by the corresponding 
response header) are denied if the server runs on low TCP connection 
resources.
</p>
<p>
Unknown clients may get blocked. mod_qos prefers clients 
which communicate with the server instantaneously and fast, 
and denies access to slow clients sending data irregularly, 
violating other rules or loading different content types than 
the majority of the other clients do.
</p>
<p>
The directive to enable this is called 
<a href="index.html#QS_ClientPrefer"><code>QS_ClientPrefer</code></a>. When 
using this feature, you should define how to detect the "good" clients 
using the <a href="index.html#QS_VipIPHeaderName"><code>QS_VipIPHeaderName</code></a> 
directive. It is also recommended to configure a static value for the 
<a href="index.html#QS_ClientContentTypes"><code>QS_ClientContentTypes</code></a> 
directive.
</p>

<a name="kernel"></a>
<h3>Kernel and iptables</h3>
<p>
You should also ensure to have the kernel parameters of your server adjusted 
to meet the requirements of a web server (many ports, short close timeouts).
</p>
<p>
Example:
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# example settings
net.core.somaxconn = 32000
net.core.netdev_max_backlog = 32000
net.ipv4.ip_local_port_range = 9999 61000
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_slow_start_after_idle = 0
</pre></td></tr></table> 

<p>
Your firewall in front or your Apache web server also performs important 
tasks related to DoS prevention - but the configuration of your FW is out of 
the scope of this article. However, iptables can also be fun...
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# limit the number of new connections (active after reaching the burst limit only):
iptables -A INPUT -p tcp --dport 80,443 -m limit \
  --state NEW --limit 60/minute --limit-burst 250 -j ACCEPT

# limit the number of established/concurrent connections:
iptables -A INPUT -m state --state RELATED,ESTABLISHED \
  -m limit --limit 50/second --limit-burst 50 -j ACCEPT

# limit the connections from a single source IP to 100:
iptables -A INPUT -p tcp --syn --dport 80,443 -m connlimit \
  --connlimit-above 100 -j REJECT
</pre></td></tr></table> 

</td></tr>
</tbody>
</table>
<br>
<hr>
<SMALL><SMALL>&copy; 2016, Pascal Buchbinder</SMALL></SMALL>
</body>
</html>
