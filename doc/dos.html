<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
 <title>mod_qos - Denial of Service Prevention</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />
<meta name="author" content="Pascal Buchbinder" />
<meta name="KeyWords" content="Quality of Service, Apache Web Server, Web application security, WAF, Open Source Software, AdNovum Informatik, Secure Reverse Proxy, Denial of Service (DoS) Prevention" />
<link rel="shortcut icon" href="favicon.ico" />
<style TYPE="text/css">
<!--  
  body {
	background-color: white;
	color: black;
	font-family: sans-serif, arial, verdana;
	font-weight: normal;
	text-align: left;
  }
  a:link    { color:#00673F; text-decoration:none; }
  a:visited { color:#00673F; text-decoration:none; }
  a:focus   { color:black; text-decoration:underline; }
  a:hover   { color:black; text-decoration:underline; }
  a:active  { color:black; text-decoration:underline; }
  .btable   { font-size:0.75em; }
-->
</style>
</head>
<body>
<!--

 Quality of service module for Apache Web Server.

 See http://opensource.adnovum.ch/mod_qos/ for further details.

 Copyright (C) 2016 Pascal Buchbinder

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 as published by the Free Software Foundation; either version 2
 of the License, or (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 MA 02110-1301, USA.

-->
<table>
<tbody>
<tr><td><img src="images/mod_qos_s.gif" alt="mod_qos" /></td>
    <td style="vertical-align: bottom;"><h1>Denial of Service Prevention</h1></td></tr>
<tr><td>&nbsp;</td>
    <td>


<p>
mod_qos cannot only be used to implement QoS by controlling your Apache 
web server's traffic but may also help you to protect 
you web site against denial of servive (DoS) attacks. The two features 
of mod_qos helping you in doing this, are the possibility to measure the 
bandwith used for a TCP connection (and the possibility to enfore that 
the requiements concerning the minimum banthwith is fulfilled) and the
existence of event counters per client's IP addresses (allowing you 
to limit the number of events a client may cause on your web site).
</p>
<p>
<i>
Note: Users may not use a unique IP addresses but their addresses may 
be shared by multiple clients when using an intermediate proxy server. 
This is expecially true for B2B applications.
</i>
</p>
<p>
This documentation shall give you an idea how you could use mod_qos 
within your Apache web server helping you to defense against the following 
DoS attacks:
<ul>
<li><i>Low-bandwidth DoS attacks</i><br>
The attacker tries to keep many TCP connections to your web server open, 
only sending partitial request data peridically (just engough not triggering 
any inactivty timeouts). The target is to occupy all available connections 
(running threads of your Apache server) so that nobody else can connect.
</li>
<li><i>HTTP GET/POST flood DoS attacks</i><br>
The attacker sends a huge amount of HTTP requests to your web server without 
awaiting the server's response. This requires only little traffic for the 
attacker but may occupy your server's threads and consums computing resources 
(CPU, memory). Some attackers scan your web site prior an attack measuring 
the duration it takes to answer the request in order to find out the most 
expensive calls.
</li>
</ul>
</p>
<p>
The following is a step-by-step checklist about potential configuration 
options you want to apply to improve your Apache server's DoS resistence. 
It shall give you an idea about which parameter you might want to set.
</p>

<a name="basic"></a>
<h3>Basic Settings</h3>
<p>
Hardware is inexpensive. Today's CPUs offers many cores allowing the processing 
of many threads in parallel and memory price is as low as never before. So allow 
your Apache server to serve many requests / TCP connections in parallel by setting 
a "high" value for its <a href="http://httpd.apache.org/docs/2.2/mod/mpm_common.html#maxclients"<code>MaxClients</code> <img src="images/link.png"/></a> 
parameter (and the corresponding <code>ServerLimit</code>/<code>ThreadsPerChild</code>  
values). I'm going to use 896 in the following examples. This is not an absolute 
value. Is propably not even a particular "high" value if you are fighting against a 
<i>low-bandwidth DoS attack</i>. Maybe it is fine for a quad-core Intel CPU serving 
several thousand concurrent users but you might choose a different value suitable your 
environment (note that each tread requires about 1 to 2 MB of memory). Just adapt all 
other values accordingly.
</p>
<p>
Other imporant Apache base settings are timeouts. 
One is the <a href="http://httpd.apache.org/docs/2.2/mod/core.html#timeout"><code>TimeOut</code> <img src="images/link.png"/></a>  
diretive defining the idle timeout while waiting for data on the network socket, 
the other is directive is 
<a href="http://httpd.apache.org/docs/2.2/mod/core.html#keepalivetimeout"><code>KeepAliveTimeout</code> <img src="images/link.png"/></a>, telling the Apache server for how long to 
wait for a subsequent request before closing an idle connection. Keep-Alive is an
important feature to accelerate your web server but your should disable it if the 
server runs out of free connections. Disabling Keep-Alive will give more users a 
chance to connect to and send a HTTP request if your server becones too busy and don't 
has any free slots anymore. mod_qos's <a href="index.html#QS_SrvMaxConnClose"><code>QS_SrvMaxConnClose</code></a> directive allows you to disable Keep-Alive in such a situation.
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# maximum number of active TCP connections is limited to 896 (limited
# by the available memory, adjust the settings according to the used
# hardware):
MaxClients                          896

# idle timeout (while the server is waiting for TCP packets):
TimeOut                              10

# keep alive (enabled, but only until 85% of all connections are busy):
KeepAlive                            on
KeepAliveTimeout                      5
MaxKeepAliveRequests                 30
<a href="index.html#QS_SrvMaxConnClose">QS_SrvMaxConnClose</a>                   85%
</pre></td></tr></table>

<a name="connections"></a>
<h3>Connections per IP</h3>
<p>
There is no reason to allow a single IP address to open an unlimited number of 
TCP connections. The <a href="index.html#QS_SrvMaxConnPerIP"><code>QS_SrvMaxConnPerIP</code></a> 
directive can be used to limit the connections a single IP is allowed to open.
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# don't allow more than 30 TCP connections per client source address
# if the server has 400 or more open connections:
<a href="index.html#QS_SrvMaxConnPerIP">QS_SrvMaxConnPerIP</a>               30 400
</pre></td></tr></table>

<a name="datarate"></a>
<h3>Minimum Data Rate</h3>
<p>
The definition of a minimum upload/download throughput a client must generate 
(the bytes sent/received by the client per seconds) is a very imporant protection 
mechanism against <i>low-bandwidth DoS attacks</i>. 
The <a href="index.html#QS_SrvMinDataRate"><code>QS_SrvMinDataRate</code></a> directive 
and be used to implement this rule.
</p>
Syntax: <code><a href="index.html#QS_SrvMinDataRate">QS_SrvMinDataRate</a> &lt;bytes per second&gt; &lt;max bytes per second&gt; &lt;connections&gt;</code><br>

<p>It offers three parameters. The first defines the 
minimum data rate a client must achieve when this limitation becomes active and the 
second parameter defines the throughput a client must achive when the server reaches 
its <code>MaxClients</code> setting. The third parameter defines the number of busy 
connections to enable this restriction.
</p>
<img src="images/SrvMinDataRate.png"/>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# minimum request/response data reate if the server has 500 or more
# open connections:
<a href="index.html#QS_SrvMinDataRate">QS_SrvMinDataRate</a>          120 1500 500
</pre></td></tr></table>
<p>
You might also want to have a lock at the Apache module 
<a href="http://httpd.apache.org/docs/2.2/mod/mod_reqtimeout.html">mod_reqtimeout <img src="images/link.png"/></a> 
(available since Apache 2.2.15) which may be used to set various timeouts for 
receiving the request headers and the request body from the client.
</p>

<a name="block"></a>
<h3>Repeat Offender</h3>
<p>
A very effective measurement is the possibility to block client IP addresses automatically 
for a certain period if they violate a rule multiple times respecively if they cause 
errors many times. The <a href="index.html#QS_ClientEventBlockCount"><code>QS_ClientEventBlockCount</code></a> 
directive can be used to do this. It defines how often a "block event" (the Apache 
process environment variable <a href="index.html#QS_Block"><code>QS_Block</code></a>) 
may occure during a defined period of time. This enhances the effect of the above limitations. 
Incomming TCP connections are rejected if a client IP address reaches this threshold.
</p>
<p>
The <a href="index.html#QS_SetEnvIfStatus"><code>QS_SetEnvIfStatus</code></a> is one of mod_qos's 
directive which may be used to define an event which must not occur too frequently.
</p>
<p>
The following example blocks clients if they cause more than 20 erros within 5 minutes.
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# block clients violating some basic rules frequently (don't allows more than 20
# violations within 5 minutes):
<a href="index.html#QS_ClientEventBlockCount">QS_ClientEventBlockCount</a> 20 300
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        400                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        405                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        406                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        408                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        413                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        414                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        500                <a href="index.html#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        <a href="index.html#QS_SrvMinDataRate">QS_SrvMinDataRate</a>  <a href="#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        <a href="index.html#QS_SrvMaxConnPerIP">QS_SrvMaxConnPerIP</a> <a href="#QS_Block">QS_Block</a>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        <a href="index.html#BrokenConnection">BrokenConnection</a>   <a href="#QS_Block">QS_Block</a>
</pre></td></tr></table>
<p>
This is just an example of events you might want to limit.<br>
If you want to prevent from SSL DoS attacks as well, you might also want to block 
clients opening TCP connections not sending any HTTP data.
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
<a href="index.html#QS_SetEnvIfStatus">QS_SetEnvIfStatus</a>        <a href="index.html#NullConnection">NullConnection</a>     <a href="#QS_Block">QS_Block</a>
</pre></td></tr></table>

<a name="clients"></a>
<h3>Requests per IP</h3>
<p>
Rules limiting a clients number of requests to a resource may be configured using the 
<a href="index.html#QS_ClientEventLimitCount"><code>QS_ClientEventLimitCount</code></a> 
directive. This provides an event counter per IP address and you may specify how 
ofen a client may cause this event within a defined period of time. Such a limitation 
might defense <i>HTTP GET/POST flood DoS attacks</i>, especially if you know which 
requests are the most expensive ones.
</p>
<p>You may use any request attributes to distinguish between "expensive" (resources 
your server takes long to process) and "inexpensive" (like static resource files which 
can be send to the client immediately). One could be the request's URL any you may use the 
<a href="http://opensource.adnovum.ch/mod_setenvifplus/#SetEnvIfPlus"><code>SetEnvIfPlus</code></a> 
directive to process them.
</p>

<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
# don't allow a client IP to access a "handler" (not a static resource like
# a jpg, gif, ..) more than 20 times per minute:
<a href="index.html#QS_ClientEventLimitCount">QS_ClientEventLimitCount</a>          20 60 SlowRequest
SetEnvIfPlus              Request_URI / SlowRequest
SetEnvIfPlus              Request_URI .*\.(jpg)|(jpeg)|(gif)|(png)|(js)|(css)$ !SlowRequest

# deny a client IP for 10 minutes if he violates the rule above 3 times
<a href="index.html#QS_ClientEventLimitCount">QS_ClientEventLimitCount</a>          3 600 SlowRepeatedlySlow
QS_SetEnvIf SlowRequest_Counter=20 SlowRepeatedlySlow=1
</pre></td></tr></table> 



<pre>
---------
 QS_ClientEventLimitCount 

</pre>
<p>
It is also possible that you enable this limitation only if the server 
reaches a predefined number of busy connections. You can achieve this by 
deleting the <a href="index.html#QS_Block"><code>QS_Block</code></a> 
event if the server has less connections. 
The <a href="index.html#QS_AllConn"><code>QS_AllConn</code></a> 
variable tells you the number of busy TCP connections and the 
<a href="index.html#QS_SetEnvIf"><code>QS_SetEnvIf</code></a> directive 
allows you to set or unset variables.<br>
The follwing example unsets the <a href="index.html#QS_Block"><code>QS_Block</code></a> 
variable as long as the server has less than 599 connections.
</p>
<table border="0" cellspacing="5" cellpadding="10" width="100%"><tr><td bgcolor="#E2EDE2"><pre>
<a href="index.html#QS_SetEnvIf">QS_SetEnvIf</a>                  <a href="index.html#QS_AllConn">QS_AllConn</a>=^[12345]?[0-9]{1,2}$ !SlowRequest
</pre></td></tr></table> 
<pre>
<hr>
---------
 QS_ClientGeoCountryPriv 
---------
 QS_ClientPrefer
---------
tcp
net.core.somaxconn = 32000
net.core.netdev_max_backlog = 32000
net.ipv4.ip_local_port_range = 9999 61000
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_slow_start_after_idle = 0
---------
iptables
# limit the number of new connections (active after reaching
# the burst limit only)
iptables -A INPUT -p tcp --dport 80,443 -m limit \
  --state NEW --limit 60/minute --limit-burst 250 -j ACCEPT
# limit the number of established/concurrent connections
iptables -A INPUT -m state --state RELATED,ESTABLISHED \
  -m limit --limit 50/second --limit-burst 50 -j ACCEPT
# limit the connections from a single source IP to 100
iptables -A INPUT -p tcp --syn --dport 80,443 -m connlimit \
  --connlimit-above 100 -j REJECT
</pre>

</td></tr>
</tbody>
</table>
<br>
<hr>
<SMALL><SMALL>&copy; 2016, Pascal Buchbinder</SMALL></SMALL>
</body>
</html>
